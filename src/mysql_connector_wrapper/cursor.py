from typing import Any, Dict, Iterator, List, Optional, Tuple, Union
import mysql.connector
from .exceptions import QueryError


class Cursor:
    def __init__(
        self, connection: "DatabaseConnection", dictionary: bool = True, **kwargs: Any
    ):
        """Initialize a database cursor.

        Args:
            connection: MySQL connection object
            dictionary: If True, returns rows as dictionaries (default: True)
            **kwargs: Additional cursor parameters supported by mysql.connector
        """
        self.connection = connection
        self.params = {"dictionary": dictionary, **kwargs}
        self.cursor = None

    def __enter__(self) -> "DatabaseCursor":
        """Context manager entry point."""
        self.cursor = self.connection.cursor(**self.params)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """Context manager exit point."""
        if self.cursor:
            self.cursor.close()
            self.cursor = None

    def execute(
        self, query: str, params: Optional[Union[Dict, List, Tuple]] = None
    ) -> "DatabaseCursor":
        """Execute a SQL query.

        Args:
            query: SQL query to execute
            params: Parameters for the query

        Returns:
            Self for method chaining

        Raises:
            QueryError: If query execution fails
        """
        try:
            self.cursor.execute(query, params)
            return self
        except mysql.connector.Error as err:
            raise QueryError(f"Query execution failed: {err}") from err

    def executemany(
        self, query: str, params_seq: List[Union[Dict, List, Tuple]]
    ) -> "DatabaseCursor":
        """Execute a SQL query multiple times.

        Args:
            query: SQL query to execute
            params_seq: Sequence of parameters for multiple executions

        Returns:
            Self for method chaining

        Raises:
            QueryError: If query execution fails
        """
        try:
            self.cursor.executemany(query, params_seq)
            return self
        except mysql.connector.Error as err:
            raise QueryError(f"Query execution failed: {err}") from err

    def fetchone(self) -> Optional[Dict[str, Any]]:
        """Fetch the next row from the result set.

        Returns:
            A single row or None if no more rows
        """
        return self.cursor.fetchone()

    def fetchall(self) -> List[Dict[str, Any]]:
        """Fetch all rows from the result set.

        Returns:
            List of all remaining rows
        """
        return self.cursor.fetchall()

    def fetchmany(self, size: int = None) -> List[Dict[str, Any]]:
        """Fetch the next set of rows from the result set.

        Args:
            size: Number of rows to fetch

        Returns:
            List of rows
        """
        return self.cursor.fetchmany(size)

    def __iter__(self) -> Iterator[Dict[str, Any]]:
        """Make cursor iterable."""
        return self.cursor.__iter__()

    @property
    def rowcount(self) -> int:
        return self.cursor.rowcount

    @property
    def lastrowid(self) -> Optional[int]:
        """Get the ID generated by the last INSERT operation."""
        return self.cursor.lastrowid

    def commit(self) -> None:
        self.connection.commit()

    def rollback(self) -> None:
        self.connection.rollback()

    def callproc(self, procname: str, args: Optional[List] = None) -> Optional[List]:
        """Call a stored procedure.

        Args:
            procname: Name of the stored procedure
            args: Parameters for the stored procedure

        Returns:
            Result of the stored procedure call

        Raises:
            QueryError: If stored procedure call fails
        """
        try:
            return self.cursor.callproc(procname, args)
        except mysql.connector.Error as err:
            raise QueryError(f"Stored procedure call failed: {err}") from err

    def close(self) -> None:
        if self.cursor:
            self.cursor.close()
            self.cursor = None

    def table_exists(self, table_name: str) -> bool:
        try:
            self.execute(f"SHOW TABLES LIKE %s", (table_name,))
            return bool(self.fetchone())
        except:
            return False

    def column_exists(self, table_name: str, column_name: str) -> bool:
        try:
            self.execute(f"SHOW COLUMNS FROM {table_name} LIKE %s", (column_name,))
            return bool(self.fetchone())
        except:
            return False
